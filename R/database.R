#' Write an object to a character string or recreate it from a character string.
#' @description Writes an ASCII text representation of an R object to a character string,
#' or uses one to recreate the object.
#' If applying this function to a data.frame, it will do this on each rows of given columns,
#' and also transform columns between datetime and character.
#'
#' @param x An ojbect or a data.frame.
#' @param mutate If \code{TRUE}, apply the function on the given columns.
#' If \code{FALSE}, apply the function on the object.
#' @param vars,vars.time A list of columns generated by \code{\link[dplyr:vars]{vars()}},
#' a character vector of column names, a numeric vector of column positions, or \code{NULL}.
#' \code{vars.time} is the columns names of datetime.
#' @param tz a character string that specifies which time zone to parse the date with.
#' The string must be a time zone that is recognized by the user's OS.
#' If \code{NULL}, use the current time zone.
#'
#' @return Transformed object.
#'
#' @examples
#' s <- flightscanner:::ListUnpack(LETTERS)
#' flightscanner:::ListPack(s)
#' d <- flightscanner:::ListUnpack(iris, mutate = TRUE, vars = "Species")
#' d <- flightscanner:::ListPack(d, mutate = TRUE, vars = "Species")
#' d$Species <- unlist(d$Species)
#' d
ListUnpack <- function(x, mutate = FALSE, vars = NULL) {
  if (!mutate) {
    paste(utils::capture.output(dput(x)), collapse = "")
  } else if (is.data.frame(x)){
    y <- if (is.null(vars)) {
      mutate_if(x, is.list, ~ map_chr(., ListUnpack, mutate = FALSE))
    } else
      mutate_at(x, vars, ~ map_chr(., ListUnpack, mutate = FALSE))
    mutate_if(y, lubridate::is.POSIXt, as.character)
  } else stop("x should be a data.frame.")
}


#' @rdname ListUnpack
ListPack <- function(x, mutate = FALSE, vars = NULL, vars.time = vars(ends_with("Time")),
                     tz = "UTC") {
  if (!mutate) {
    eval(parse(text = x))
  } else if (is.data.frame(x)){
    mutate_at(x, vars, ~ map(., ListPack, mutate = FALSE)) %>%
      mutate_at(vars.time, ~ lubridate::ymd_hms(., tz = tz))
  } else stop("x should be a data.frame.")
}


#' Insert rows into a table.
#' @description Insert rows into a table.
#' If the table has key, it will ignore the duplicate rows indexed by the key.
#' It assumes that the table has been created beforehand.
#'
#' @param conn A \code{\link[RSQLite:SQLiteConnection-class]{SQLiteConnection}} object,
#' as returned by \code{\link[DBI:dbConnect]{dbConnect()}}.
#' @param name Name of the table.
#' @param value A data frame of values.
#' The column names must be consistent with those in the target table in the database.
#' @param ... Other arguments used by individual methods.
#'
#' @import DBI
#' @export
#'
#' @examples
#' con <- DBI::dbConnect(RSQLite::SQLite(), ":memory:")
#' DBI::dbWriteTable(con, "iris", iris[0, ])
#' dbAppendTableNew(con, "iris", iris)
dbAppendTableNew <- function(conn, name, value, ...) {
  value <- ListUnpack(value, mutate = TRUE)
  
  sum(sapply(1:NROW(value), function(i) {
    x <- tryCatch(dbAppendTable(conn, name, value[i, , drop = FALSE], ...),
                  warning = function(w) 1,
                  error = function(e) {
                    if (grepl("^UNIQUE constraint failed", e$message)) 0 else stop(e)
                  })
    if (inherits(x, "error")) stop(x) else x
  }))
}


#' Connect to a SQLite database and create tables.
#' @description Connect to a SQLite database file. And check it the following tables exists:
#' price, itinerary, leg, segment, carrier, agent, and place. If not, create them.
#'
#' @param conn A \code{\link[RSQLite:SQLiteDriver-class]{SQLiteDriver}}
#' or \code{\link[RSQLite:SQLiteConnection-class]{SQLiteConnection}}.
#' @param dbname The path to the database file. Don't use two exceptions:
#' \itemize{
#'   \item{
#'   \code{""} will create a temporary on-disk database.
#'   The file will be deleted when the connection is closed.
#'   }
#'   \item{
#'   \code{":memory:"} or \code{"file::memory:"} will create a temporary in-memory database.
#'   }
#' }
#'
#' @return An object of class \code{\link[RSQLite:SQLiteConnection-class]{SQLiteConnection}}.
#' If can't connect to SQLite driver, return 1.
#'
#' @import DBI
#' @export
#'
#' @examples
#' \dontrun{
#' dbCreateDB(dbname = "flight.db")
#' unlink("flight.db")
#' }
dbCreateDB <- function(conn = RSQLite::SQLite(), dbname = "flight.db") {
  if (inherits(conn, "SQLiteConnection")) {
    con <- conn
  } else if (inherits(conn, "SQLiteDriver") && dbCanConnect(conn)) {
    con <- dbConnect(conn, dbname = dbname)
  } else return(1)
  
  if (!dbExistsTable(con, "price")) {
    dbCreateTable(con, SQL("price"), c(SearchTime = "TEXT NOT NULL",
                                       OutboundLegId = "TEXT NOT NULL",
                                       InboundLegId = "TEXT NOT NULL",
                                       PricingOptions = "BLOB"))
  }
  
  if (!dbExistsTable(con, "itinerary")) {
    fields <- c(OutboundLegId = "TEXT NOT NULL",
                InboundLegId = "TEXT NOT NULL")
    columns <- paste(paste(dbQuoteIdentifier(con, names(fields)), fields), collapse = ",\n  ")
    query <- paste0("CREATE TABLE itinerary (\n  ", columns,
                    ",\n  PRIMARY KEY (`OutboundLegId`, `InboundLegId`)\n)")
    dbExecute(con, query)
  }
  
  if (!dbExistsTable(con, "leg")) {
    dbCreateTable(con, SQL("leg"), c(Id = "TEXT PRIMARY KEY NOT NULL",
                                     SegmentIds = "BLOB NOT NULL",
                                     OriginId = "INTEGER NOT NULL",
                                     DestinationId = "INTEGER NOT NULL",
                                     DepartureTime = "TEXT NOT NULL",
                                     ArrivalTime = "TEXT NOT NULL",
                                     Duration = "INTEGER NOT NULL",
                                     No.Stops = "INTEGER NOT NULL",
                                     Stops = "BLOB"))
  }
  
  if (!dbExistsTable(con, "segment")) {
    dbCreateTable(con, SQL("segment"), c(Id = "TEXT PRIMARY KEY NOT NULL",
                                         OriginId = "INTEGER NOT NULL",
                                         DestinationId = "INTEGER NOT NULL",
                                         DepartureTime = "TEXT NOT NULL",
                                         ArrivalTime = "TEXT NOT NULL",
                                         Duration = "INTEGER NOT NULL",
                                         CarrierId = "INTEGER NOT NULL",
                                         OperatingCarrierId = "INTEGER NOT NULL",
                                         FlightNumber = "TEXT NOT NULL"))
  }
  
  if (!dbExistsTable(con, "carrier")) {
    dbCreateTable(con, SQL("carrier"), c(Id = "INTEGER PRIMARY KEY NOT NULL",
                                         Code = "TEXT NOT NULL",
                                         Name = "TEXT NOT NULL",
                                         ImageURL = "TEXT"))
  }
  
  if (!dbExistsTable(con, "agent")) {
    dbCreateTable(con, SQL("agent"), c(Id = "INTEGER PRIMARY KEY NOT NULL",
                                       Name = "TEXT NOT NULL",
                                       Type = "TEXT NOT NULL",
                                       ImageURL = "TEXT"))
  }
  
  if (!dbExistsTable(con, "place")) {
    dbCreateTable(con, SQL("place"), c(Id = "INTEGER PRIMARY KEY NOT NULL",
                                       ParentId = "INTEGER",
                                       Code = "TEXT",
                                       Type = "TEXT NOT NULL",
                                       Name = "TEXT NOT NULL"))
  }
  
  con
}


#' Save data to SQLite database.
#' @description Get data from the request response object,
#' and save data to the corresponding tables in the SQLite database.
#' Tables includes: price, itinerary, leg, segment, carrier, agent, and place.
#'
#' @param conn A \code{\link[RSQLite:SQLiteConnection-class]{SQLiteConnection}} object,
#' as returned by \code{\link[DBI:dbConnect]{dbConnect()}}.
#' @param x A \code{\link[httr:response]{response()}} object.
#'
#' @export
#'
#' @examples
#' \dontrun{
#' # Get response from API
#' SetAPI("skyscanner-skyscanner-flight-search-v1.p.rapidapi.com", "YOUR_API_KEY")
#' resp <- CreateSession(origin = "SFO", destination = "LHR", startDate = "2019-07-01")
#' resp <- PollSession(respondPOST = resp)
#'
#' # Connect to SQLite database
#' con <- dbCreateDB(dbname = "flight.db")
#' SaveData(con, resp)
#' }
SaveData <- function(conn, x) {
  if (!inherits(x, "response")) stop("x should be a response() object.")
  
  data <- GetData(x)
  dbAppendTableNew(conn, "price", data$price)
  dbAppendTableNew(conn, "itinerary", data$itineraries)
  dbAppendTableNew(conn, "leg", data$legs)
  dbAppendTableNew(conn, "segment", data$segments)
  dbAppendTableNew(conn, "carrier", data$carriers)
  dbAppendTableNew(conn, "agent", data$agents)
  dbAppendTableNew(conn, "place", data$places)
  
  invisible()
}
